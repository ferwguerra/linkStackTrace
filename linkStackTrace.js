"use strict";
/*
 * oauthToken: GitHub OAuth Token string
 * stackTrace: stack trace string
 * userOrRepo: GitHub user or user/repo string
 * commitIsh: commit-ish string or null to keep GitHub’s SHA (latest commit on main branch that touched the file)
 * callback: function(result, rateLimitReset), called when finished.
 *           result is the linked stack trace,
 *           rateLimitReset is the Date when the rate limit will reset, or null if the rate limit wasn’t hit.
 */
function linkStackTrace(oauthToken, stackTrace, userOrRepo, commitIsh, callback) {
    function fixCommitIsh(url) {
        if (commitIsh !== null)
            return url.replace(/[a-z0-9]{40}/, commitIsh);
        return url;
    }
    
    var lines = stackTrace.split('\n');
    
    // [line format, file name, plain line]*
    // in line format, \0file\0 is replaced with a URL to file name on GitHub
    var analyzedLines = lines.map(function(line) {
        var parsedLine = /^(.*)\((.*):(\d*)\)$/.exec(line);
        if (parsedLine != null && typeof(parsedLine[1] == "string") && typeof(parsedLine[2] == "string") && typeof(parsedLine[3] == "string")) {
            var before = parsedLine[1];
            var filename = parsedLine[2];
            var linenum = parsedLine[3];
            return [before + "([" + filename + ":" + linenum + "](\0file\0#L" + linenum + "))", filename, line];
        } else {
            return [null, null, line];
        }
    });
    
    var allFilenames = analyzedLines.map(function(analyzedLine) {
        return analyzedLine[1];
    });
    var filenames = allFilenames.filter(function(element, index) {
        return allFilenames.indexOf(element) === index;
    });
    
    var userRepo;
    if (userOrRepo.indexOf('/') != -1) // userOrRepo.contains('/')
        userRepo = "repo:" + userOrRepo;
    else
        userRepo = "user:" + userOrRepo;

    var files = new Map();
    var filesLength = 0;
    var notFound = {},
        ambiguous = {},
        nameMismatch = {},
        rateLimitHit = {},
        unknownError = {};
    var rateLimitReset = null;
    function cont() {
        if (++filesLength === filenames.length) {
            // that was the last search, continue with the rest of the function
            var linkedLines = analyzedLines.map(function(line) {
                if (line[1] !== null && line[0] !== null && typeof(files.get(line[1])) === "string") {
                    return line[0].replace("\0file\0", fixCommitIsh(files.get(line[1])));
                } else {
                    return line[2];
                }
            });
            
            var linkedStackTrace = linkedLines.join('\n');
            
            var footer = "\n<sup>Generated by [linkStackTrace](http://lucaswerkmeister.github.io/linkStackTrace/)</sup>";
            var ret = linkedStackTrace;
            if (ret.indexOf(footer) == -1)
                ret += footer;
            
            callback(ret, rateLimitReset);
        }
    }
    filenames.forEach(function(filename) {
        var req = new XMLHttpRequest();
        req.open("GET", "https://api.github.com/search/code?" + 
                 "access_token=" + oauthToken + "&" +
                 "q=" + filename + "+in:path+" + userRepo + "&" +
                 "per_page=2");
        req.setRequestHeader("Accept", "application/vnd.github.v3+json");
        req.onload = function(e) {
            if (req.readyState === 4) {
                if (req.status === 200) {
                    var response = JSON.parse(req.responseText);
                    if (response.total_count === 0) {
                        console.log("file " + filename + " not found");
                        files.set(filename, notFound);
                        cont();
                        return;
                    } else if (response.total_count > 1) {
                        if (response.items[0].name == filename && response.items[1].name != filename) {
                            // looks ambiguous, but actually isn’t:
                            // the first match is what we want, and the second match is “valid” for GitHub
                            // (for example, .../metamodel/Predicates.java matched Metamodel.java)
                            // but we can drop it.
                            console.log("file " + filename + " yielded several results, but is still unambiguous");
                            // skip the return
                        } else if (response.items[1].name == filename && response.items[0].name != filename) {
                            // same case, except the second result is our match.
                            // I’m not sure why GitHub would choose this order, but it happens.
                            console.log("file " + filename + " yielded several results, but is still unambiguous");
                            response.items[0] = response.items[1];
                            // skip the return
                        } else {
                            console.log("file " + filename + " ambiguous between '" + response.items[0].path + "', '" + response.items[1].path + "' and possibly more");
                            files.set(filename, ambiguous);
                            cont();
                            return;
                        }
                    }
                    // exactly one match
                    var match = response.items[0];
                    if (match.name != filename) {
                        console.log("file name " + match.name + " doesn’t match expected file name " + filename);
                        files.set(filename, nameMismatch);
                        cont();
                        return;
                    }
                    files.set(filename, match.html_url);
                    cont();
                } else if (req.status === 403) {
                    // rate limit hit
                    console.error("Rate limit hit!");
                    files.set(filename, rateLimitHit);
                    rateLimitReset = new Date(req.getResponseHeader("X-RateLimit-Reset") * 1000);
                    cont();
                } else {
                    console.error(req.status + ": " + req.statusText);
                    console.error(req.responseText);
                    files.set(filename, unknownError);
                    cont();
                }
            }
        };
        req.send();
    });
}

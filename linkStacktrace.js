function linkStacktrace(oauthToken, stackTrace, userOrRepo, callback) {
    var lines = stackTrace.split('\n');
    
    // [line format, file name, plain line]*
    // in line format, \0file\0 is replaced with a URL to file name on GitHub
    var analyzedLines = lines.map(function(line) {
        var parsedLine = /^(.*)\((.*):(\d*)\)$/.exec(line);
        if (parsedLine != null && typeof(parsedLine[1] == "string") && typeof(parsedLine[2] == "string") && typeof(parsedLine[3] == "string")) {
            var before = parsedLine[1];
            var filename = parsedLine[2];
            var linenum = parsedLine[3];
            return [before + "([" + filename + ":" + linenum + "](\0file\0#L" + linenum + "))", filename, line];
        } else {
            return [null, null, line];
        }
    });
    
    var allFilenames = analyzedLines.map(function(analyzedLine) {
        return analyzedLine[1];
    });
    var filenames = allFilenames.filter(function(element, index) {
        return allFilenames.indexOf(element) === index;
    });
    
    var userRepo;
    if (userOrRepo.indexOf('/') != -1) // userOrRepo.contains('/')
        userRepo = "repo:" + userOrRepo;
    else
        userRepo = "user:" + userOrRepo;
    
    var files = {}; // map from filename → URL
    var filesLength = 0;
    var notFound = {},
        ambiguous = {},
        nameMismatch = {},
        rateLimitHit = {},
        unknownError = {};
    var rateLimitReset = null;
    function cont() {
        if (++filesLength === filenames.length) {
            // that was the last search, continue with the rest of the function
            var linkedLines = analyzedLines.map(function(line) {
                if (line[1] !== null && line[0] !== null && typeof(files[line[1]]) === "string") {
                    return line[0].replace("\0file\0", files[line[1]]);
                } else {
                    return line[2];
                }
            });
            
            var linkedStacktrace = linkedLines.join('\n');
            
            var footer = "<sup>Generated by [linkStacktrace](http://lucaswerkmeister.github.io/linkStacktrace/)</sup>\n";
            var ret = linkedStacktrace;
            if (ret.indexOf(footer) == -1)
                ret += footer;
            ret = ret.slice(0, -1); // remove last newline
            
            callback(ret, rateLimitReset);
        }
    }
    filenames.forEach(function(filename) {
        var req = new XMLHttpRequest();
        req.open("GET", "https://api.github.com/search/code?" + 
                 "access_token=" + oauthToken + "&" +
                 "q=" + filename + "+in:path+" + userRepo + "&" +
                 "per_page=2");
        req.setRequestHeader("Accept", "application/vnd.github.v3+json");
        req.onload = function(e) {
            if (req.readyState === 4) {
                if (req.status === 200) {
                    var response = JSON.parse(req.responseText);
                    if (response.total_count === 0) {
                        console.log("file " + filename + " not found");
                        files[filename] = notFound;
                        cont();
                        return;
                    } else if (response.total_count > 1) {
                        if (response.items[0].name == filename && response.items[1].name != filename) {
                            // looks ambiguous, but actually isn’t:
                            // the first match is what we want, and the second match is “valid” for GitHub
                            // (for example, .../metamodel/Predicates.java matched Metamojel.java)
                            // but we can drop it.
                            console.log("file " + filename + " yielded several results, but is still unambiguous");
                            // skip the return
                        } else {
                            console.log("file " + filename + " ambiguous between '" + response.items[0].path + "', '" + response.items[1].path + "' and possibly more");
                            files[filename] = ambiguous;
                            cont();
                            return;
                        }
                    }
                    // exactly one match
                    var match = response.items[0];
                    if (match.name != filename) {
                        console.log("file name " + match.name + " doesn’t match expected file name " + filename);
                        files[filename] = nameMismatch;
                        cont();
                        return;
                    }
                    files[filename] = match.html_url;
                    cont();
                } else if (req.status === 403) {
                    // rate limit hit
                    console.error("Rate limit hit!");
                    files[filename] = rateLimitHit;
                    rateLimitReset = new Date(req.getResponseHeader("X-RateLimit-Reset") * 1000);
                    cont();
                } else {
                    console.error(req.status + ": " + req.statusText);
                    console.error(req.responseText);
                    files[filename] = unknownError;
                    cont();
                }
            }
        };
        req.send();
    });
}
